import mongoose from "mongoose";
import bcrypt from 'bcrypt';
import validator from 'validator';
import session from 'express-session';
import UserModel from "../models/UserModel.js";

/**
    req.body:
        app.get('/giraffe', (req, res) => {
            console.log(req.body.key1) //value1
            console.log(req.body.key2) //value2
        })

    req.params:
        app.get('/giraffe/:number', (req, res) => {
            console.log(req.params.number)
        })
        GET http://localhost:3000/giraffe/1
    
    req.query:
        GET http://localhost:3000/animals?page=10
        app.get('/animals', () => {
            console.log(req.query.page) // 10
        })
*/

// get all
const getAllUsers = async (req, res) => {
    const data = await UserModel.find( {} );
    res.status(200).json(data);
}

// get single
const getSingleUser = async (req, res) => {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(404).json({error: "Invalid object ID"})
    }
    const data = await UserModel.findById(id);
    if (!data) {
        return res.status(404).json({error: "Does not exist"});
    }
    res.status(200).json(data);
}

/**
    Express-session provides built-in middleware for session management in Express.js 
    applications. When a session is created, express-session generates a unique session ID 
    and stores session data on the server. It also sends the session ID to the client as 
    a cookie. On subsequent requests, express-session middleware automatically retrieves 
    session data from the server using the session ID included in the cookie.
 */
/**
    When you use express-session in your Express.js application, it adds a property named 
    "session" to the request object (req).

    This session object allows you to interact with the session data associated with the 
    current request. You can read from and write to this object to manage session state, 
    store user data, and implement session-based features like authentication and 
    authorization.
 */
const getUserProfile = async (req, res) => {
    if (req.session && req.session.user) {
        res.send(`${req.session.user.email} is logged in`);
    } else {
        res.status(401).send('Unauthorized');
    }
}

const getUserHomePage = async (req, res) => {
    // Get user's personalized content
};

/**
    Once the server sends a cookie to the client, the cookie is automatically 
    included in subsequent HTTP requests to the same domain. In an Express.js application, 
    you can access cookies sent from the client using the req.cookies object.
    const sessionId = req.cookies.sessionId;
 */
const logInUser = async (req, res) => {
    try {
        // Find the user by username
        const user = await UserModel.findOne({ email: req.body.email });
    
        if (!user) {
          return res.status(404).json({ message: 'User not found' });
        }
    
        // Compare passwords
        if (await bcrypt.compare(req.body.password, user.password)) {
            req.session.user = { email: req.body.email };
            /**
                In this example, req.session.id contains the session ID 
                generated by express-session. We use res.cookie() to set a 
                cookie named sessionId with the session ID value
             */
            res.cookie('sessionId', req.session.id, {
                maxAge: 3600000, // Cookie expiration time in milliseconds (1 hour)
                httpOnly: true, // Ensures the cookie is not accessible via JavaScript
                secure: false, // Set to true if using HTTPS
                sameSite: 'strict' // Restricts cookie to same-site requests
            });
            return res.status(200).json({ user }).send();
        }
        // return 401 by default
        return res.status(401).json({ message: 'Incorrect password' });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
      }
}

function randomThumbnail() {
    const randomId = Math.floor(Math.random() * 1000);
    return "https://picsum.photos/id/" + randomId + "/200/125";
}

function getRandomVideosFromDb(quantity) {
    const fetchAllVideoData = async () => {
        let videos = []; 
        const response = await fetch("http://localhost:5000/api/video", {
            method: 'GET',
            headers: {
                "Content-Type": 'application/json'
            }
        });
        if (response.ok) {
            const data = await response.json();
            for (let i = 0; i < quantity; i++) {
                videos.push(data[Math.floor(Math.random() * data.length)]._id);
            }
            console.log("Successfully retrieved user video data");
        } else {
            console.log("Could not retrieve user video data");
        }
        return videos;
    }
    return fetchAllVideoData();
}

// create new
const createUser = async (req, res) => {
    const profilePicture = randomThumbnail();
    const createdAt = Date.now();
    const updatedAt = Date.now();

    // Additional checks if needed (e.g., domain validation, SMTP check)
    if (!validator.isEmail(req.body.email)) {
        return res.status(400).json({ error: "Invalid email format" });
    }

    try {
        // Check if user exists
        const userExists = await UserModel.findOne({ email: req.body.email });
        if (userExists) {
            return res.status(409).json({ message: 'Email already exists' });
        }

        const salt = await bcrypt.genSalt();
        const hashedPassword = await bcrypt.hash(req.body.password, salt);

        // Generate random videos for user
        const videos = await getRandomVideosFromDb(10);
        // Create user in DB
        const model = await UserModel.create({ 
            password: hashedPassword, 
            email: req.body.email,
            // dateOfBirth: dateOfBirth,
            profilePicture: profilePicture,
            videos: videos,
            // channelName: channelName,
            // userUrl: userUrl,
            // location: location,
            createdAt: createdAt,
            updatedAt: updatedAt,
            // socialMedia: socialMedia,
            // settings: settings
        });
        req.session.user = { email: req.body.email };
        res.cookie('sessionId', req.session.id, {
            maxAge: 3600000, // Cookie expiration time in milliseconds (1 hour)
            httpOnly: true, // Ensures the cookie is not accessible via JavaScript
            secure: false, // Set to true if using HTTPS
            sameSite: 'strict' // Restricts cookie to same-site requests
        });
        console.log(req.session.id);
        return res.status(201).json(model).send();
    } catch (error) {
        return res.status(400).json({ 
            error: error.message
        })
    }
}

// delete
const deleteUser = async (req, res) => {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(404).json({error: "Invalid object ID"})
    }
    const data = await UserModel.findOneAndDelete({_id: id});
    if (!data) {
        return res.status(404).json({error: "Does not exist"});
    }
    res.status(200).json(data);
}

// update
const updateUser = async (req, res) => {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(404).json({error: "Invalid object ID"})
    }
    const data = await UserModel.findOneAndUpdate(
        {_id: id}, {...req.body}
    )
    if (!data) {
        return res.status(404).json({error: "Does not exist"});
    }
    res.status(200).json(data);
}

export {
    getAllUsers,
    getSingleUser,
    getUserProfile,
    createUser, 
    logInUser,
    deleteUser,
    updateUser
}